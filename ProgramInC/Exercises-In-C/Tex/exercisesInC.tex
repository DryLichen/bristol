%----------------------%

\input{structure}

\usepackage[title]{appendix}

\begin{document}

\begingroup
\thispagestyle{empty} % Suppress headers and footers on the title page
\begin{tikzpicture}[remember picture,overlay]
\draw (current page.center) node [fill=ocre!30!white,fill opacity=0.6,text opacity=1,inner sep=1cm]{\Huge\centering\bfseries\sffamily\parbox[c][][t]{\paperwidth}{\centering COMSM1201 : Exercises in C\\[15pt] % Book title
{\Large Neill Campbell}\\[20pt] % Subtitle
{\huge Department of Computer Science, University of Bristol}}}; % Author name
\end{tikzpicture}
\vfill
\endgroup

%----------------------------------------------------------------------------------------
%	COPYRIGHT PAGE
%----------------------------------------------------------------------------------------

\newpage
~\vfill
\thispagestyle{empty}

\noindent Copyright \copyright\ 2022 Neill Campbell\\ % Copyright notice

\noindent Formatted in \LaTeX, based on the Legrand Orange Book from \textsc{book-website.com}\\

\noindent This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

\noindent \textit{\date} % Printing/edition date

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\usechapterimagefalse % If you don't want to include a chapter image, use this to toggle images off - it can be enabled later with \usechapterimagetrue

\chapterimage{chapter_head_1.pdf} % Table of contents heading image

\pagestyle{empty} % Disable headers and footers for the following pages

\tableofcontents % Print the table of contents itself

\cleardoublepage % Forces the first chapter to start on an odd page so it's on the right side of the book

\pagestyle{fancy} % Enable headers and footers again





%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 0/1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/hello-world.png}
\chapter{Hello World}

Many of the exercises in this Chapter are taken from the book "C by Dissection".

\readchapter{B}{Hello World!}
\input{twice}
\input{letterc}

\readchapter{C}{Grammar}
\input{aplusplus}
\input{randomness}

\readchapter{D}{Flow Control}
\input{findmax}
\input{loveodd}
\input{lcg}
\input{higherlower}
\input{atm}
\input{trianglenums}

\readchapter{E}{Functions}
\input{hailstone_basic}
\input{hailstone_seq}
\input{primes_basic}
\input{whichtriangle}
\input{timeflies}
\input{dirichlet}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/pet.png}
\chapter{Mathematics \& Characters}

\nopartorder

\readchapter{F}{Mathematics \& Characters}
\input{unitcircle}
\input{montepi}
\input{leibniz}
\input{irrational}
\input{fibword_phi}
\input{vowelness}
\input{planettrium}
\input{bob}
\input{secretcodes}

\readchapter{G}{Prettifying}
\input{roulette}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/strings.pdf}
\chapter{$1D$ Arrays \& Strings}

\nopartorder
\readchapter{H}{$1D$ Arrays}
\input{microwave}
\input{ipod}
\input{yahtzee}
\input{rule110}
\input{devils}
\input{countingsort}
\input{fibword_subs}

\readchapter{I}{Strings}
\input{palindrome}
\input{itoa}
\input{roman}
\input{soundex}
\input{fibword_strings}
\input{strmerge}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/grids.pdf}
\chapter{$2D$ Arrays}

\input{crossword}
\input{binarygrid}
\input{lifeall}
\input{lifewars}
\input{wireworld}
\input{forestfire}
\input{dla}
\input{langton}
%\input{ncurses}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 5 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/pet.png}
\chapter{Files, argc and Graphics}

Data for these exercises
are available in the github repository {\em Data}
, including lists of English words in {\em Data/Words}.

\input{anagrams}
\input{ansi}
\input{introsdl}
\input{insertionsort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 6 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 7 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{chapter}{6}
\chapterimage{../Pictures/Insertionsort-edited.png}
\chapter{Recursion}

\nsection{Word Ladders}
\input{wordladder_gen}
\input{wordladder_cons}
\input{wordladder_full}
\input{maze_rec}
\input{unlock}
\input {sierpinski_carpet}
\input {sierpinski_triangle}
\input{primefactors}
%\input{mo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 8 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/bookcase.jpg}
\chapter{Searching Boards}

\input{conway}
\input{eighttile}
\input{bookcase}
\input{rollerboard}
\input{carpark}


%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 9 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/btree.png}
\chapter{ADTs \& Data Structures I}

\input{indexarr}
\input{boolarr}
\input{sets}
\input{polymorphism}
\input{soll}
\input{sudoku}
\input{multivalmaps}
\input{rhymes}
\input{advent}


%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 10 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/hash.jpg}
\chapter{Trees \& Hashing}

\input{depthtree}
\input{twotrees}
\input{huffman}
\input{bintreevis}
\input{lowestca}
\input{fastermvm}
\input{doublehash}
\input{sepchain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 11 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/nursery-rhymes.jpg}
\chapter{ADTs II \& Data Structures }

\input{hashpoly}
\input{cuckoo}
\input{dicts}
\input{lisp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% WEEK 12 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterimage{../Pictures/ttl2.jpg}
\chapter{Parsing Data}

\newcommand{\bb}{white}
\newcommand{\ff}{black}

\newcommand{\sixel}[6]{%
\begin{tikzpicture}[scale=0.333, every node/.style={scale=0.333}]
\matrix[sixelstyle]
{
|[fill=#1]| \& |[fill=#2]| \\
|[fill=#3]| \& |[fill=#4]| \\
|[fill=#5]| \& |[fill=#6]| \\
};
\end{tikzpicture}%
}

\newcommand{\sepsix}[6]{%
\begin{tikzpicture}[scale=0.333, every node/.style={scale=0.333}]
\matrix[sepsixstyle]
{
|[fill=#1]| \& |[fill=#2]| \\
|[fill=#3]| \& |[fill=#4]| \\
|[fill=#5]| \& |[fill=#6]| \\
};
\end{tikzpicture}%
}


\input{mode7}

\begin{exercise}
Implement a teletext rendering system. The $1000$ character input
file should be read in using \verb^argv[1]^.

There are many ambiguities
as to how various sequences of codes should be rendered. To help with
this, several example files have been posted on the unit web page. 
If there is still doubt, make a best-guess and state your assumptions
in the code.

Submit the testing you have undertaken, including examples and a description
of your strategies. This should convince us that you have tested every line
of code, and that it works correctly. If there are still issues/bugs state
them clearly. Also, point out any bugs that you have successfully found using
these approaches. Submit a file named \verb^testing.txt^, along with any other
files you feel necessary in the appropriate directory.

No particular strategy is mandated. You may wish to explore a couple and briefly
discuss strengths and weaknesses. 

Undertake an extension of your choosing. Examples of these include:
\begin{itemize}
\item A system that allows you to quickly author teletext pages (perhaps
using a recursive-descent parser?)
\item Automatic image to teletext conversion.
\item Automatic (simple) html to teletext conversion (and/or vice-versa).
\end{itemize}
Remember, that the assessment is based on the quality of your coding, so choose
something to demonstrate an aspect of programming or software engineering
that you haven't had a chance to use in the main assignment. Submit a file named
\verb^extension.txt^ outlining, in brief, your contribution. 

\subsection*{Hints}

\begin{itemize}
\item Don't add graphics too early - the
code is easier to test and debug with textual output to begin with.
\item I advise you to use SDL for your graphics output. The library provided previously contained
two functions to deal with printing characters~: \verb^Neill_SDL_ReadFont()^ and
\verb^Neill_SDL_DrawString()^. The font file \verb^m7fixed.fnt^ provides the basic
characters required here, but not the sixels. By understanding how the font data
is rendered, the double height version of the characters should be relatively simple.
\item Don't try to do all aspects of this at once - begin with coloured characters only. Add more
advanced functionality later.
\item Plan how you are going to store your data early in the design process.
Does each character need its own data structure? Does each line? Can this be abstracted?
\end{itemize}

Please create a directory structure, so that I can easily find the
different subsections.  Your testing strategy will be explained in
\verb^testing.txt^, and your extension as \verb^extension.txt^. For
the source and extension sections, make sure there's a
\verb^Makefile^, so that I can easily build the code.

\begin{verbatim}
            ------Top Directory------
            |            |          |           
            |            |          |           
            |            |          |            
            |            |          |             
          source      testing    extension   
            |            |          |
           ...          ...   extension.txt
           ...          ...       ...
         Makefile     Makefile    ...  
                    testing.txt
\end{verbatim}

Bundle all of these up as one {\bf single} \verb^.zip^ submission -
not one for each subsection.
\end{exercise}

\nsection{Guido van Robot}

\begin{center}
\includegraphics[scale=0.75]{./gnuLinuxGvR.jpg}
\end{center}

From \wwwurl{http://gvr.sourceforge.net/}
{\small
\begin{quote}
Guido van Robot can face in one of four directions, north, east, south, and west. He turns only 90 degrees at a time, so he can't face northeast, for instance. In Guido's world, streets run east-west, and are numbered starting at 1. There are no zero or negative street numbers. Avenues run north-south, and are also numbered starting at 1, with no zero or negative avenue numbers. At the intersection of a street and avenue is a corner. Guido moves from one corner to to the next in a single movement. Because he can only face in one of four directions, when he moves he changes his location by one avenue, or by one street, but not both!
\end{quote}
}

\subsection*{Simple .wld File}

\begin{verbatim}
Robot 5 4 N 1
Wall 3 2 N 6
Wall 2 3 E 4
Wall 3 6 N 6
Wall 8 3 E 2
Wall 8 6 E
\end{verbatim}
\begin{center}
\includegraphics[scale=0.5]{../Pictures/GvRsimple1.jpg}
\end{center}

\subsection*{\bf Simple .gvr File}
\begin{verbatim}
move
move
move
move
turnoff
\end{verbatim}
\begin{center}
\includegraphics[scale=0.5]{./GvRsimple2.jpg}
\end{center}


\subsection*{Do Loops}
\begin{verbatim}
do 2 :
   putbeeper
   move
turnoff
\end{verbatim}

\subsection*{Conditional Loop}
\begin{verbatim}
while front_is_clear :
   putbeeper
   move
turnoff
\end{verbatim}

\subsection*{Branching}
\begin{verbatim}
do 13 :
   if front_is_clear :
      putbeeper
      move
   else :
      turnleft
turnoff
\end{verbatim}

\subsection*{The Formal Grammar}
{\small
\begin{verbatim}
<PROGRAM>   ::= <BLOCK>
<BLOCK>     ::= "turnoff" |
                "move" <BLOCK> |
                "turnleft" <BLOCK> |
                "pickbeeper" <BLOCK> |
                "putbeeper" <BLOCK> |
                <DO> <BLOCK> |
                <WHILE> <BLOCK> |
                <IF> <BLOCK>
<DO>        ::= "do" <num> ":"
                   <BLOCK>
<WHILE>     ::= "while" <TEST> ":"
                   <BLOCK>
<IF>        ::= "if" <TEST> ":"
                   <BLOCK> |
              "if" <TEST> ":"
                   <BLOCK>
              "else" ":"
                   <BLOCK>
<TEST>      ::= <WALL> | <BEEP> | <COMPASS>
\end{verbatim}
}

{\small
\begin{verbatim}
<WALL>      ::= "front_is_clear" |
                "front_is_blocked" |
                "left_is_clear" |
                "left_is_blocked" |
                "right_is_clear" |
                "right_is_blocked"
<BEEP>      ::= "next_to_a_beeper" |
                "not_next_to_a_beeper" |
                "any_beepers_in_beeper_bag" |
                "no_beepers_in_beeper_bag"
<COMPASS>   ::= "facing_north" |
                "not_facing_north" |
                "facing_south" |
                "not_facing_south" |
                "facing_east" |
                "not_facing_east" |
                "facing_west" |
                "not_facing_west"
\end{verbatim}
}

This ignores some Guido instructions, e.g. \verb^elseif^
and \verb^define^. It also doesn't well explain how to spot
the end of a \verb^DO^ etc. which is marked by a reduction in
indentation.
The definition of \verb^.wld^ files is so simple a recursive
descent parser (and hence grammar) is not required.

\begin{exercise}
\begin{itemize}

\item (25\%) To implement a recursive descent parser - this says
whether or not the given \verb^.gvr^ and \verb^.wld^ follow the formal grammar or not.
The input files are specified via \verb^argv[1]^ (\verb^.gvr^) and \verb^argv[2]^ (\verb^.wld^) .

\item (25\%) To implement an interpreter, so that the instructions are
executed. Printing the world and robot to screen
using simple characters is fine, but many will wish to use SDL.

\item (25\%) To show a testing strategy on the above -
you should give details of
white-box and black-box testing done on your code. Describe any
test-harnesses used. Give examples of the output of many different
programs. Convince me that every line of your C code
has been tested.

\item (25\%) To show an extension to the project in a direction of
your choice. It should demonstrate your understanding of some aspect
of programming or S/W engineering. If you extend the formal grammar
make sure that you show the new, full grammar.

Submit the program(s) and a Makefile so that I can:

\item Compile the parser by typing `make parse'.
\item Compile the interpreter by typing `make interp'.
\item Compile the extension by typing `make extension'.
\item Submit a test strategy report called test.txt. This will include
sample outputs, any code written especially for testing etc.
\item Submit an extension report called `extend.txt'. This is quite
brief and explains the extension attempted.

\item You need to be able to load a world file and a \verb^.gvr^
and say if they are valid of not.
\item Don't try to write the entire program in one go. Try a cut
down version of the grammar first, e.g.:
{\small
\begin{verbatim}
<PROGRAM>   ::= <BLOCK>
<BLOCK>     ::= "turnoff" |
                "move" <BLOCK> |
                "turnleft" <BLOCK> |
                "pickbeeper" <BLOCK> |
                "putbeeper" <BLOCK>
<DO>        ::= "do" <num> ":"
                   <BLOCK>
\end{verbatim}
}
\item Some issues, such as what happens if you hit a wall
are not clear from the formal grammar. In this case, use your
common sense, or do what the real program does.
\end{itemize}
\end{exercise}

\input{turtle}

\begin{exercise}
Implement a recursive descent parser - this will report
whether or not a given turtle program follows the formal grammar or not.
The input file is specified via \verb^argv[1]^ - there is {\bf no} output if
the input file is {\bf valid}. Elsewise, a non-zero \verb^exit^ is made.

{\bf Extend} the parser, so it becomes an interpreter. The instructions are
now `executed'. Do not write a new program for this, simply extend your
existing parser. Output is via SDL. You may find the function call
\verb^SDL_RenderDrawLine^ useful.

Show a testing strategy on the above -
you should give details of
unit testing, white/black-box testing done on your code. Describe any
test-harnesses used. In addition, give examples of the output of many different
turtle programs. Convince me that every line of your C code
has been tested.

Show an extension to the project in a direction of
your choice. It should demonstrate your {\bf understanding} of some aspect
of programming or S/W engineering. If you extend the formal grammar
make sure that you show the new, full grammar.

\subsection*{Hints}
\begin{itemize}
\item All four sections above are equally weighted.
\item Don't try to write the entire program in one go. Try a cut
down version of the grammar first, e.g.:
{\small
\begin{verbatim}
<MAIN>        ::= "{" <INSTRCTLST>
<INSTRCTLST>  ::= <INSTRUCTION><INSTRCTLST> |
                  "}"
<INSTRUCTION> ::= <FD> | <LT> | <RT>
<FD>          ::= "FD" <VARNUM>
<LT>          ::= "LT" <VARNUM>
<RT>          ::= "RT" <VARNUM>
<VARNUM>      ::= number
\end{verbatim}
}
\item The language is simply a sequence of words (even the semi-colons),
so use \verb^fscanf()^.
\item Some issues, such as what happens if you use an undefined variable,
or if you use a variable before it is set, are not explained by the formal
grammar. Use your own common-sense, and explain what you have done.
\item Once your parser works, extend it to become an interpreter. DO NOT
aim to parse the program first and then interpret it separately. Interpreting
and parsing are inseparably bound together.
\item Start testing very early - this is a complex beast to test and trying to
do it near the end won't work.
\end{itemize}

\subsection*{Submission}
Your testing strategy will be explained in \verb^testing.txt^, and your extension
as \verb^extension.txt^. For the parser, interpreter and extension sections, make
sure there's a \verb^Makefile^, so that I can easily build the code using \verb^make parse^,
\verb^make interp^ and \verb^make extension^. Submit a single \verb^turtle.zip^ file.

\end{exercise}

\input{nlab}

\input{cawk}

\begin{exercise}
Write a C program to implement the above formal grammar. Your program
should read in a cawk program (argv[1]) and expect the data
file to be read from standard input (or from argv[2] if specified).

The marks are split as follows:
\begin{itemize}
\item (25\%) To implement a recursive descent parser - this says
whether or not a given CAWK program follows the formal grammar or not.

\item (25\%) To implement an interpreter, so that the instructions are
executed.

\item (25\%) To show a testing strategy on the above -
you should give details of
white-box and black-box testing done on your code. Describe any
test-harnesses used. Give examples of the output of many different
cawk programs.

\item (25\%) To show an extension to the project in a direction of
your choice. It should demonstrate your understanding of some aspect
of programming or S/W engineering. If you extend the formal grammar
make sure that you show the new, full grammar.
\end{itemize}

Submit the program(s) and a Makefile so that I can:

\begin{itemize}
\item Compile the parser by typing `make parse'.
\item Compile the interpreter by typing `make interp'.
\item Compile the extension by typing `make extension'.
\end{itemize}

In addition:
\begin{itemize}
\item Submit a test strategy report called test.txt. This will include
sample outputs, any code written especially for testing etc.
\item Submit an extension report called `extend.txt'. This is quite
brief and explains the extension attempted.
\end{itemize}

\end{exercise}

\input{nal}
\begin{exercise}
\begin{itemize}

\strut

\item {\bf (40\%)}
Implement a parser. The \verb^.nal^ file should be read in using
\verb^argv[1]^.  If the file is parsed correctly, the only output should
be:
\begin{terminaloutput}
Parsed OK
\end{terminaloutput}

\item {\bf (30\%)}
Implement an interpreter, building on top of the parser in the
manner described in the lectures. Do not write a brand new program -
interpretation will be done alongside parsing.

\item {\bf (20\%)}
Submit the testing you have undertaken, including examples and a
description of your strategies. This should convince us that you have
tested every line of code, and that it works correctly. If there are
still issues/bugs state them clearly. Also, point out any bugs that
you have successfully found using these approaches. Submit a file named
\verb^testing.txt^, along with any other files you feel necessary. Due
to the recursive nature of this assignment testing is non-trivial -
simply submitting many \verb^.nal^ files that `work' is not sufficient.
No particular strategy is mandated. You may wish to explore a couple
and briefly discuss strengths and weaknesses.

\item {\bf (10\%)}
Undertake an extension of your choosing.  Remember, that the assessment is
based on the quality of your coding, so choose something to demonstrate
an aspect of programming or software engineering that you haven't
had a chance to use in the main assignment. Submit a file named
\verb^extension.txt^ outlining, in brief, your contribution.
\end{itemize}

\subsection*{Hints}
\begin{itemize}
\item Don't try to write the entire program in one go. Try a cut
down version of the grammar first. Build-up from the \verb^01s^
example given in lectures.
\item Some issues, such as what happens if you use an undefined variable,
or if you use a variable before it is set, are not explained by the formal
grammar. Use your own common-sense, and explain what you have done.
\item Once your parser works, extend it to become an interpreter. DO NOT
aim to parse the program first and then interpret it separately.
Interpreting and parsing are inseparably bound together.
\end{itemize}
 
\subsection*{Submission}

Your testing strategy will be explained in \verb^testing.txt^, and
your extension as \verb^extension.txt^. For the parser, interpreter
and extension sections , make sure there's one \verb^Makefile^, so that I
can easily build the code using \verb^make parse^, \verb^make interp^
and \verb^make extension^. I've given an example \verb^makefile^ in the
usual place, but this is an example only - yours may be different.
I wrote only one program \verb^nal.c^ and built the two
different version by setting a \verb^#define^ {\bf via the makefile with}
\verb^-DINTERP^. Inside the code itself \verb^#ifdef INTERP^ and \verb^#endif^ are used.
Also make sure that basic testing is available using \verb^make testparse^ and \verb^make testinterp^.

\noindent Place all the files required for your submission in a single \verb^.zip^ file called \verb^nal.zip^ - this file will not contain other zipped files.

\end{exercise}

\include{nuclei}


\appendix
\begin{appendices}

\chapterimage{../Pictures/style.jpg}
\chapter{House Style}
\label{appendix:style}
\input{style}

\chapterimage{../Pictures/peer2peer.jpg}
\chapter{Peer Assessment}
\input{peer}


\chapterimage{../Pictures/exam.jpg}
\chapter{Lab Tests}

\input{examconditions}
\input{howtosubmit}
\input{codestyle}

\newpage
\nsection{Anagrams}
\subsection*{Part 1 (60\%)}

An anagram is a rearrangement of a word, using all the letters.
Two words are said to be anagrams if they have the same characters,
but in a different order.
For instance the words `parsley', `players' and `replays'
are all anagrams of each other.

Since you need to rearrange the words, two identical words, by definition, are not anagrams.

Using the following template, fill in the function \verb^anagram()^,
so that the program runs successfully~:
\begin{verbatim}
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

int anagram(char s1[], char s2[]);

int main(void)
{
   assert(anagram("elvis", "lives") == 1);
   assert(anagram("dreads", "sadder") == 1);
   assert(anagram("replays", "parsley") == 1);
   assert(anagram("listen", "silent") == 1);
   assert(anagram("orchestra", "carthorse") == 1);

   /* Two identical words are not anagrams */
   assert(anagram("elvis", "elvis") == 0);

   assert(anagram("neill", "neil") == 0);
   assert(anagram("neil", "neill") == 0);
   assert(anagram("horse", "short") == 0);

   return 0;
}

int anagram(char s1[], char s2[])
{


}
\end{verbatim} 

Obviously, your program will need to run for other, unseen but similar, test cases. 

\subsection*{Part 2 (40\%)}

A deranged anagram has two words with the same characters, but the same
character does not appear in the same position.

The words `elvis' and `lives' are not a derangement since the `s' is
in the same position in both words.
However, `dreads' and `sadder' are, since no letter appears in the
same position between the two words.

Extend the program above so that the following assertions, inside \verb^main()^
are correct:
\begin{verbatim}
   assert(derange("elvis", "lives") == 0);
   assert(derange("dreads", "sadder") == 1);
   assert(derange("replays", "parsley") == 1);
   assert(derange("listen", "silent") == 0);
   assert(derange("orchestra", "carthorse") == 1);
\end{verbatim}



\nsection{Isograms}
\subsection*{Part 1 (60\%)}

An isogram is a word that has no repeating letters. For instance the words `graciously', `disgraceful' and
`productively' are all isograms. However, the word `dazzlingly' is not (it contains the letters `z' and `l'
twice).

Using the following template, fill in the function \verb^isogram()^, so that the program runs
successfully~:
\begin{verbatim}
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

int isogram(char *s);

int main(void)
{
   assert(isogram("programming") == 0);
   assert(isogram("housewarmings") == 0);
   assert(isogram("abductions") == 1);
   assert(isogram("housewarming") == 1);
   assert(isogram("hydromagnetics") == 1);
   assert(isogram("uncopyrightable") == 1);
   return 0;
}

int isogram(char *s)
{


}
\end{verbatim} 

\subsection*{Part 2 (40\%)}
Using the \verb^isogram()^ function written above, write a program which finds the {\it longest} isogram in a
file of words. The name of the file is provided via the use of \verb^argv^.
On success, the program simply outputs the longest word and its length, nothing else. For
example~:
\begin{verbatim}
$ ./parttwo eowl_shuffle.txt
waveringly (10)
\end{verbatim}

The file may contain many isograms of (equal) longest length. In this case,
outputting any one of them will do. 

\nsection{Mutating Boards}
\subsection*{Part 1 (60\%)}

Write a {\bf function} that fills up a square board, randomly,
with an integer $0 \dots 9$. Use a:\\
\verb^#define N 20^\\
to define the size of the board.  Write another function to print the board.
The board may look something like:

{\small
\begin{verbatim}
36753562912709360626
18792023759228973612
93194784503610632061
55476569374525474430
78688431492068926649
50487172722610615949
09177115977673656394
81293908850963856115
98481030444476317596
21785741859753883189
64333860488897764303
09254059469224775481
28936802105110850646
25862847240629908131
10340391969338056640
04626756987282996027
61321599149107587048
04296104222055290283
80409196254499360502
94351743146942264128
\end{verbatim}
}

Write a
function to `mutate' the board. Mutating is done like this:
\begin{itemize}
\item Choose two random locations which are {\bf horizontally adjacent} (next to each other left-right).
\item Swap these two numbers on the board if the left one is greater than the right one, numerically.
\item Choose two random locations which are {\bf vertically adjacent} (next to each other up-down).
\item Swap these two numbers on the board if the upper one is greater than the lower one, numerically.
\item Repeat the above steps (N*N*N) times.
\end{itemize}

Now print out the board. It should look something like~:
{\small
\begin{verbatim}
00000000000001111224
00000001111111233456
00000111112222244456
00001122222333445666
00112222223333555667
01112223333334556678
01112223334445556779
01122333344445556789
01223334444455666789
01223344445556666789
01223344455666667789
01224444456666777889
01234455566677777889
01234555666677788899
01234555666778888899
12234566677788888999
12345567777888889999
12445677788888899999
34446678889999999999
46678899999999999999
\end{verbatim}
}

Ensure that if you change the size of your array, by changing your \verb^#define^
that the program still operates correctly.

\subsection*{Part 2 (40\%)}
Adapt the code above, so that the algorithm is:
\begin{itemize}
\item Choose two numbers at random locations on the board.
\item Check that of these two numbers, the one closest to the centre of the array
is numerically less than the number furthest away from the centre. If not, swap them.
\item Repeat the above steps (N*N*N*N) times.
\end{itemize}

Once again randomise the array initially, and ensure that after changing your \verb^#define^
the program still works correctly.

When $N=21$, the array may look something like:
{\samepage
{\small
\begin{verbatim}
999998887777788899999
999987666656666788999
998876554444555678899
998665443333444566889
987654333222233456789
876543322112223345678
865443211111112334568
765432111000011234568
765422100000001234567
764321100000001223467
764321100000001123457
764322100000001223467
765422100000001224567
865432110000011234568
865432211111122334568
876543322212223345678
987654333222233456789
988665444333344567889
998876555444455678899
999887666656666789999
999998887777788899999
\end{verbatim}
}
}

\end{appendices}

\end{document}
